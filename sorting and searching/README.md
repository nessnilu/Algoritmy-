**Анализ алгоритмов**
1)	**Сортировка выбором** – это алгоритм, который последовательно находит минимальный элемент в неотсортированной части массива и перемещает его в начало. 

Анализ:

•	На каждом проходе находится минимальный элемент в неотсортированной части

•	Найденный элемент меняется местами с первым элементом неотсортированной части

•	Внешний цикл выполняется n-1 раз

•	Внутренний цикл делает n-i-1 сравнений на i-й итерации

•	Общее количество сравнений: (n-1) + (n-2) + ... + 1 = n(n-1)/2

Временная сложность: O(n2), при любых входных данных выполняются два вложенных цикла, где внутренний цикл делает n-i-1 сравнений для каждого i внешнего цикла.

2)	**Сортировка пузырьком** — это алгоритм, который многократно сравнивает и меняет местами соседние элементы, пока массив не будет полностью отсортирован.

Анализ:

•	Последовательно сравниваются соседние элементы

•	Элементы меняются местами при неправильном порядке

•	Самые большие элементы "всплывают" к концу массива

•	Внешний цикл выполняется n-1 раз

•	Внутренний цикл делает n-i-1 сравнений на i-й итерации

•	Можно оптимизировать с флагом, прерывая выполнение при отсутствии обменов

Временная сложность: O(n2), Два вложенных цикла выполняют пропорциональное n² количеству операций, где каждый элемент может потребовать многократных сравнений и обменов.

3)	**Сортировка вставками** — это алгоритм, который постепенно строит отсортированную последовательность, вставляя каждый новый элемент в правильную позицию среди уже упорядоченных элементов.
   
Анализ: 

•	Массив делится на отсортированную и неотсортированную части

•	Каждый новый элемент вставляется в правильную позицию отсортированной части

•	Для вставки элементы сдвигаются вправо

•	Внешний цикл выполняется n-1 раз

•	Внутренний цикл в худшем случае делает i сравнений и сдвигов

Временная сложность: O(n2), В худшем случае для каждого элемента требуется сравнение со всеми элементами отсортированной части, что дает квадратичную зависимость.

4)	**Сортировка слиянием** — это алгоритм типа "разделяй и властвуй", который рекурсивно делит массив на две части, сортирует каждую из них, а затем объединяет в отсортированный массив.
   
Анализ: 

•	Массив рекурсивно делится пополам до отдельных элементов

•	Отсортированные части объединяются в правильном порядке

Временная сложность: O(n log n), Массив делится пополам на log n уровней, и на каждом уровне выполняется линейное количество операций при слиянии.
	 
5)	**Сортировка Шелла** — это усовершенствованная сортировка вставками, которая сначала сортирует элементы, находящиеся далеко друг от друга, постепенно уменьшая расстояние между сравниваемыми элементами.
   
Анализ: 

•	Сортировка вставками с убывающими интервалами

•	Начинается с больших интервалов, уменьшая до 1

•	Элемны на больших расстояниях перемещаются быстрее

•	Эффективность зависит от последовательности интервалов

Временная сложность: O(n²) в худшем случае, но обычно лучше. Лучшая временная сложность: O(n log n) для некоторых последовательностей, эффективность зависит от последовательности интервалов.

6)	**Быстрая сортировка** — это эффективный алгоритм, который выбирает опорный элемент и разделяет массив на две части: элементы меньше опорного и элементы больше опорного.
   
Анализ: 

•	Выбирается опорный элемент

•	Массив разделяется на элементы меньше и больше опорного

•	Процесс рекурсивно повторяется для обеих частей

•	В среднем случае разделение близко к середине

Временная сложность: O(n log n) в среднем случае, O(n²) в худшем случае (уже отсортированный массив), в среднем случае массив делится пополам на каждом уровне рекурсии, что дает log n уровней, и на каждом уровне выполняется O(n) операций.

7)	**Пирамидальная сортировка** — это алгоритм, использующий структуру данных "куча" для сортировки, многократно извлекая максимальный элемент и перестраивая кучу.
   
Анализ: 

•	Строится двоичная max-куча из массива

•	Максимальный элемент перемещается в конец

•	Куча перестраивается для оставшихся элементов

Временная сложность: O(n log n), Построение кучи занимает O(n) времени, а каждый из n вызовов heapify занимает O(log n) времени, что в сумме дает O(n log n).

8)	**Последовательный поиск** — это простейший алгоритм поиска, который проверяет элементы массива один за другим до нахождения нужного элемента.
    
Анализ: 

•	Поочередная проверка каждого элемента массива

•	Работает с любыми массивами (отсортированными и нет)

Временная сложность: O(n), требуется проверить все n элементов массива. Алгоритм не требует предварительной сортировки данных и работает с любыми типами массивов (отсортированными и неотсортированными).


9)	**Бинарный поиск** — это эффективный алгоритм для отсортированных массивов, который на каждом шаге делит область поиска пополам.

Анализ:

•	Работает только с отсортированными массивами

•	На каждом шаге область поиска уменьшается вдвое

•	Сравнение с средним элементом текущего диапазона

Временная сложность: O(log n), На каждом шаге область поиска уменьшается вдвое. Максимальное количество итераций равно log₂n, где n - размер массива. Алгоритм требует предварительной сортировки массива.


10)	**Интерполирующий поиск** — это улучшенный бинарный поиск, который использует интерполяцию для предсказания позиции искомого элемента.
    
Анализ: 

•	Улучшенный бинарный поиск для равномерных данных

•	Позиция вычисляется по интерполяционной формуле

Временная сложность: O(log log n), Алгоритм каждый раз значительно уменьшает область поиска, особенно на равномерно распределенных данных, что дает двойной логарифм.

11)	**Поиск Фибоначчи** — это алгоритм поиска, использующий числа Фибоначчи для деления отсортированного массива на неравные части.

Анализ: 

•	Использует числа Фибоначчи для разделения массива

•	Работает без операций деления

•	Область поиска уменьшается в золотом сечении раз

Временная сложность: O(log n), Алгоритм уменьшает размер области поиска примернов φ (золотое сечение ≈ 1.618) раз на каждой итерации, что дает логарифмическую сложность аналогично бинарному поиску.
